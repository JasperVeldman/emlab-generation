"CapacityinMW", "PowerGeneratingTechnology", "capacity= v.in().filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"CapacityinMWinA", "PowerGeneratingTechnology", "capacity = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country A'}.back('x').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"CapacityinMWinB", "PowerGeneratingTechnology", "capacity = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country B'}.back('x').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) capacity = 0
[v.name, capacity]",

"PeakDemandPerZoneInMW", "ElectricitySpotMarket", "topsegments = v.out('SEGMENT_LOAD').max{it.baseLoad}.baseLoad;
try{growthfactors = v.out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){    
growthfactors=v.out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
adjustedTopSegments = topsegments*growthfactors;
return [v.outE('ZONE').inV.collect{it.name}[0], adjustedTopSegments]",

"TotalOperationalCapacityPerZoneInMW", "Zone", "t = new Table();
pp = v.in('REGION').in('LOCATION')
pp.filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.as('powerPlantCapacity').out('TECHNOLOGY').as('peakSegmentDependentAvailability').table(t){it.actualNominalCapacity}{it.peakSegmentDependentAvailability}.cap().next();
capacitySum = 0; for (row in t){capacitySum += row.getColumn('powerPlantCapacity') * row.getColumn('peakSegmentDependentAvailability')}
return [v.name, capacitySum]",


"TotalConsumptioninMWh", "DecarbonizationModel", "segmentloads = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentLoad']];
productionsum  = 0;
for(segmentload in segmentloads){
    //productionsum += segmentload.baseLoad;
    try{growthfactor = segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){
    growthfactor=segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
    productionsum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentload.baseLoad * growthfactor;
}
return productionsum;",

"CO2BankedCertificates", "DecarbonizationModel", "agents = g.idx('__types__')[[className:'emlab.gen.domain.agent.DecarbonizationAgent']];
           co2Allowances=0;
           for(agent in agents){if(agent.co2Allowances!=null) co2Allowances+=agent.co2Allowances}; return co2Allowances",

"TotalProductioninMWh", "DecarbonizationModel", "powerplants = g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']]
return [['Total Production', powerplants.in('POWERPLANT_DISPATCHPLAN').filter{it.forecast==false}.sum{f.determineProductionOfDispatchPlanInMWh(it, tick)}]]",

"NationalTotalProductioninMWh", "Zone", "powerplants = v.in('REGION').in('LOCATION')
return [v.name, powerplants.in('POWERPLANT_DISPATCHPLAN').filter{it.forecast==false}.sum{f.determineProductionOfDispatchPlanInMWh(it, tick)}]",

"CO2CapinTonpA", "Government", "try{cap = v.out('CO2CAP_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){
cap = v.out('CO2CAP_TREND').timeSeries.next()[tick.toInteger()];}
return ['CO2_cap', cap]",

"NationalMinCO2PriceinEURpTon", "NationalGovernment","try{price = v.out('MINCO2PRICE_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('MINCO2PRICE_TREND').timeSeries.next()[tick.toInteger()];}
return [v.out('GOVERNED_ZONE').collect{it.name}[0], price];",

"NationalGovernmentCash", "NationalGovernment","
return [v.out('GOVERNED_ZONE').collect{it.name}[0], v.cash];",

"EUGovernmentCash", "Government","
return v.cash;",

"SpotMarketCash", "ElectricitySpotMarket","
return [v.name, v.cash];",

"GenerationinMWh", "PowerGeneratingTechnology", "sum = 0;
ppdps = v.in('TECHNOLOGY').in('POWERPLANT_DISPATCHPLAN').filter{it.time==tick && it.status>=2 && it.forecast==false};
for(ppdp in ppdps){
    totalAmount = ppdp.getProperty('acceptedAmount') + ppdp.getProperty('capacityLongTermContract');
    hoursInSegment = ppdp.out('SEGMENT_DISPATCHPLAN').next().getProperty('lengthInHours');
    production = totalAmount * hoursInSegment;
    sum = sum + production;
}
return [v.name, sum]",

"GenerationinMWhPerSegmentA", "PowerGeneratingTechnology", "results = []
ppdps = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country A'}.back('x').in('POWERPLANT_DISPATCHPLAN').filter{it.time==tick && it.status>=2};
points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
capacity = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country A'}.back('x').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) {capacity = 0;}
total1 = 0;
total2 = 0;
total3 = 0;
total4 = 0;
total5 = 0;
total6 = 0;
total7 = 0;
total8 = 0;
total9 = 0;
total10 = 0;
total11 = 0;
total12 = 0;
total13 = 0;
total14 = 0;
total15 = 0;
total16 = 0;
total17 = 0;
total18 = 0;
total19 = 0;
total20 = 0;
money1 = 0;
money2 = 0;
money3 = 0;
money4 = 0;
money5 = 0;
money6 = 0;
money7 = 0;
money8 = 0;
money9 = 0;
money10 = 0;
money11 = 0;
money12 = 0;
money13 = 0;
money14 = 0;
money15 = 0;
money16 = 0;
money17 = 0;
money18 = 0;
money19 = 0;
money20 = 0;
sum = 0;
money = 0;
totalProduction = 0;
production = 0;
totalAmount = 0;
hoursInSegment = 0;

for(ppdp in ppdps) {
    totalAmount = ppdp.getProperty('acceptedAmount') + ppdp.getProperty('capacityLongTermContract');
    segmentNumber = ppdp.out('SEGMENT_DISPATCHPLAN').next().getProperty('segmentID');
    hoursInSegment = ppdp.out('SEGMENT_DISPATCHPLAN').next().getProperty('lengthInHours');
    production = totalAmount * hoursInSegment;
    if (segmentNumber == 1) {
    total1 = total1 + production; }
    else if (segmentNumber == 2) {
    total2 = total2 + production;
    } 
    else if (segmentNumber == 3) {
    total3 = total3 + production;
    } 
    else if (segmentNumber == 4) {
    total4 = total4 + production;
    } 
    else if (segmentNumber == 5) {
    total5 = total5 + production;
    } 
    else if (segmentNumber == 6) {
    total6 = total6 + production;
    } 
    else if (segmentNumber == 7) {
    total7 = total7 + production;
    } 
    else if (segmentNumber == 8) {
    total8 = total8 + production;
    } 
    else if (segmentNumber == 9) {
    total9 = total9 + production;
    } 
    else if (segmentNumber == 10) {
    total10 = total10 + production;
    } 
    else if (segmentNumber == 11) {
    total11 = total11 + production;
    } 
    else if (segmentNumber == 12) {
    total12 = total12 + production;
    } 
    else if (segmentNumber == 13) {
    total13 = total13 + production;
    } 
    else if (segmentNumber == 14) {
    total14 = total14 + production;
    } 
    else if (segmentNumber == 15) {
    total15 = total15 + production;
    } 
    else if (segmentNumber == 16) {
    total16 = total16 + production;
    } 
    else if (segmentNumber == 17) {
    total17 = total17 + production;
    } 
    else if (segmentNumber == 18) {
    total18 = total18 + production;
    } 
     else if (segmentNumber == 19) {
    total19 = total19 + production;
    } 
     else if (segmentNumber == 20) {
    total20 = total20 + production;
    } 
    
    
}

for (scp in points) {
id = scp.out('SEGMENT_POINT').segmentID.next();
market = scp.out('MARKET_POINT').out('ZONE').name.next();
if (market == 'Country A') {
    if (id == 1) {
   money1 = total1 * scp.price;
    } else if (id == 2) {
    money2 = total2 * scp.price;
    } 
    else if (id == 3) {
    money3 = total3 * scp.price;
    } 
    else if (id == 4) {
    money4 = total4 * scp.price;
    } 
    else if (id == 5) {
    money5 = total5 * scp.price;
    } 
    else if (id == 6) {
    money6 = total6 * scp.price;
    } 
    else if (id == 7) {
    money7 = total7 * scp.price;
    } 
    else if (id == 8) {
    money8 = total8 * scp.price;
    } 
    else if (id == 9) {
    money9 = total9 * scp.price;
    } 
    else if (id == 10) {
    money10 = total10 * scp.price;
    } 
    else if (id == 11) {
    money11 = total11 * scp.price;
    } 
    else if (id == 12) {
    money12 = total12 * scp.price;
    } 
    else if (id == 13) {
    money13 = total13 * scp.price;
    } 
    else if (id == 14) {
    money14 = total14 * scp.price;
    } 
    else if (id == 15) {
    money15 = total15 * scp.price;
    } 
    else if (id == 16) {
    money16 = total16 * scp.price;
    } 
    else if (id == 17) {
    money17 = total17 * scp.price;
    } 
    else if (id == 18) {
    money18 = total18 * scp.price;
    } 
     else if (id == 19) {
    money19 = total19 * scp.price;
    } 
     else if (id == 20) {
    money20 = total20 * scp.price;
    } 
    
}

}


totalProduction = total1 + total2 + total3 + total4 + total5 + total6 + total7 + total8 + total9 + total10 + total11 + total12 + total13 + total14 + total15 + total16 + total17 + total18 + total19 + total20;
money = money1 + money2 + money3 + money4 + money5 + money6 + money7 + money8 + money9 + money10 + money11 + money12 + money13 + money14 + money15 + money16 + money17 + money18 + money19 + money20;
if (capacity > 0) {
profit = money / capacity;}
else {
profit = 0;
}
return [v.name, profit]",

"GenerationinMWhPerSegmentB", "PowerGeneratingTechnology", "results = []
ppdps = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country B'}.back('x').in('POWERPLANT_DISPATCHPLAN').filter{it.time==tick && it.status>=2};
points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
capacity = v.in('TECHNOLOGY').as('x').out('LOCATION').out('REGION').filter{it.name=='Country B'}.back('x').filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.sum{it.actualNominalCapacity}
if(capacity == null) {capacity = 0;}
total1 = 0;
total2 = 0;
total3 = 0;
total4 = 0;
total5 = 0;
total6 = 0;
total7 = 0;
total8 = 0;
total9 = 0;
total10 = 0;
total11 = 0;
total12 = 0;
total13 = 0;
total14 = 0;
total15 = 0;
total16 = 0;
total17 = 0;
total18 = 0;
total19 = 0;
total20 = 0;
money1 = 0;
money2 = 0;
money3 = 0;
money4 = 0;
money5 = 0;
money6 = 0;
money7 = 0;
money8 = 0;
money9 = 0;
money10 = 0;
money11 = 0;
money12 = 0;
money13 = 0;
money14 = 0;
money15 = 0;
money16 = 0;
money17 = 0;
money18 = 0;
money19 = 0;
money20 = 0;
sum = 0;
money = 0;
totalProduction = 0;
production = 0;
totalAmount = 0;
hoursInSegment = 0;

for(ppdp in ppdps) {
    totalAmount = ppdp.getProperty('acceptedAmount') + ppdp.getProperty('capacityLongTermContract');
    segmentNumber = ppdp.out('SEGMENT_DISPATCHPLAN').next().getProperty('segmentID');
    hoursInSegment = ppdp.out('SEGMENT_DISPATCHPLAN').next().getProperty('lengthInHours');
    production = totalAmount * hoursInSegment;
    if (segmentNumber == 1) {
    total1 = total1 + production; }
    else if (segmentNumber == 2) {
    total2 = total2 + production;
    } 
    else if (segmentNumber == 3) {
    total3 = total3 + production;
    } 
    else if (segmentNumber == 4) {
    total4 = total4 + production;
    } 
    else if (segmentNumber == 5) {
    total5 = total5 + production;
    } 
    else if (segmentNumber == 6) {
    total6 = total6 + production;
    } 
    else if (segmentNumber == 7) {
    total7 = total7 + production;
    } 
    else if (segmentNumber == 8) {
    total8 = total8 + production;
    } 
    else if (segmentNumber == 9) {
    total9 = total9 + production;
    } 
    else if (segmentNumber == 10) {
    total10 = total10 + production;
    } 
    else if (segmentNumber == 11) {
    total11 = total11 + production;
    } 
    else if (segmentNumber == 12) {
    total12 = total12 + production;
    } 
    else if (segmentNumber == 13) {
    total13 = total13 + production;
    } 
    else if (segmentNumber == 14) {
    total14 = total14 + production;
    } 
    else if (segmentNumber == 15) {
    total15 = total15 + production;
    } 
    else if (segmentNumber == 16) {
    total16 = total16 + production;
    } 
    else if (segmentNumber == 17) {
    total17 = total17 + production;
    } 
    else if (segmentNumber == 18) {
    total18 = total18 + production;
    } 
     else if (segmentNumber == 19) {
    total19 = total19 + production;
    } 
     else if (segmentNumber == 20) {
    total20 = total20 + production;
    } 
    
    
}

for (scp in points) {
id = scp.out('SEGMENT_POINT').segmentID.next();
market = scp.out('MARKET_POINT').out('ZONE').name.next();
if (market == 'Country B') {
    if (id == 1) {
   money1 = total1 * scp.price;
    } else if (id == 2) {
    money2 = total2 * scp.price;
    } 
    else if (id == 3) {
    money3 = total3 * scp.price;
    } 
    else if (id == 4) {
    money4 = total4 * scp.price;
    } 
    else if (id == 5) {
    money5 = total5 * scp.price;
    } 
    else if (id == 6) {
    money6 = total6 * scp.price;
    } 
    else if (id == 7) {
    money7 = total7 * scp.price;
    } 
    else if (id == 8) {
    money8 = total8 * scp.price;
    } 
    else if (id == 9) {
    money9 = total9 * scp.price;
    } 
    else if (id == 10) {
    money10 = total10 * scp.price;
    } 
    else if (id == 11) {
    money11 = total11 * scp.price;
    } 
    else if (id == 12) {
    money12 = total12 * scp.price;
    } 
    else if (id == 13) {
    money13 = total13 * scp.price;
    } 
    else if (id == 14) {
    money14 = total14 * scp.price;
    } 
    else if (id == 15) {
    money15 = total15 * scp.price;
    } 
    else if (id == 16) {
    money16 = total16 * scp.price;
    } 
    else if (id == 17) {
    money17 = total17 * scp.price;
    } 
    else if (id == 18) {
    money18 = total18 * scp.price;
    } 
     else if (id == 19) {
    money19 = total19 * scp.price;
    } 
     else if (id == 20) {
    money20 = total20 * scp.price;
    } 
    
}

}


totalProduction = total1 + total2 + total3 + total4 + total5 + total6 + total7 + total8 + total9 + total10 + total11 + total12 + total13 + total14 + total15 + total16 + total17 + total18 + total19 + total20;
money = money1 + money2 + money3 + money4 + money5 + money6 + money7 + money8 + money9 + money10 + money11 + money12 + money13 + money14 + money15 + money16 + money17 + money18 + money19 + money20;
if (capacity > 0) {
profit = money / capacity;}
else {
profit = 0;
}
return [v.name, profit]",


"PriceDifferenceSegmentA", "DecarbonizationModel", "differenceA = 0;
points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick)
firstSegmentB = 0;
lastSegmentB = 0;
for(scp in points){
	id = scp.out('SEGMENT_POINT').segmentID.next();
	if (id == 1) {
	name = scp.out('MARKET_POINT').out('ZONE').name.next();
	if (name == 'Country A') {
	firstSegmentA = scp.price; }
	else{ firstSegmentB = scp.price;}
	continue;}
	else if (id == 20) {
	name = scp.out('MARKET_POINT').out('ZONE').name.next();
	if (name == 'Country A') {
	lastSegmentA = scp.price; }
	else {lastSegmentB = scp.price;} 
	continue;}
	}
	differenceA = firstSegmentA - lastSegmentA;
	differenceB = firstSegmentB - lastSegmentB;
return ['Country A', differenceA]",

"PriceDifferenceSegmentB", "DecarbonizationModel", "differenceA = 0;
points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick)
firstSegmentB = 0;
lastSegmentB = 0;
differenceB = 0;
for(scp in points){
	id = scp.out('SEGMENT_POINT').segmentID.next();
	if (id == 1) {
	name = scp.out('MARKET_POINT').out('ZONE').name.next();
	if (name == 'Country A') {
	firstSegmentA = scp.price; }
	else{ firstSegmentB = scp.price;}
	continue;}
	else if (id == 20) {
	name = scp.out('MARKET_POINT').out('ZONE').name.next();
	if (name == 'Country A') {
	lastSegmentA = scp.price; }
	else {lastSegmentB = scp.price;} 
	continue;}
	}
	differenceA = firstSegmentA - lastSegmentA;
	differenceB = firstSegmentB - lastSegmentB;
return ['Country B', differenceB]",

"FlowModel", "DecarbonizationModel", "results = []
points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
for(scp in points){
    results.add(['Segment ' + scp.out('MARKET_POINT').out('ZONE').name.next() + ' ' + scp.out('SEGMENT_POINT').segmentID.next(), scp.interconnectorFlow])
}
return results",

    
"CO2Auction", "CO2Auction", "point=v.in('MARKET_POINT').filter{it.time==tick && it.forecast==false}
if(!point.hasNext()){price = 0} else {price=point.next().getProperty('price')}
return price",

"Forc_CO2Auction", "CO2Auction", "point=v.in('MARKET_POINT').filter{it.time==tick && it.forecast==true}
if(!point.hasNext()){price = 0} else {price=point.next().getProperty('price')}
return price",

"Avg_El_PricesinEURpMWh", "Zone", "cp = v.in('ZONE').in('MARKET_POINT').filter{it.time==tick  && it.forecast==false}.toList();
[v.name, cp.sum{it.price * it.volume} / cp.sum{it.volume}];
",

"Forc_Avg_El_PricesinEURpMWh", "Zone", "cp = v.in('ZONE').in('MARKET_POINT').filter{it.time==tick+3  && it.forecast==true}.toList();
[v.name, cp.sum{it.price * it.volume} / cp.sum{it.volume}];
",

"Total_DemandinMWh", "Zone", "cp = v.in('ZONE').in('MARKET_POINT').filter{it.time==tick && it.forecast==true}.toList();
[v.name, cp.sum{it.volume}];
",

"CO2Emissions_inTonpA", "DecarbonizationModel", "ppdps=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PowerPlantDispatchPlan']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).filter{it.status>=1 && it.forecast==false}.collect();
co2Emissions = 0
for(plan in ppdps){
fuelMix=plan.out('POWERPLANT_DISPATCHPLAN').out('FUEL_MIX').collect()
singleEmission=0
    for(fuelMixElement in fuelMix){
        //fuelMixElement=fuelMix[1]
        share=fuelMixElement.share
        co2Density=fuelMixElement.out('SUBSTANCE').collect{it.co2Density}[0]*(1-plan.out('POWERPLANT_DISPATCHPLAN').out('TECHNOLOGY').collect{it.co2CaptureEffciency}[0])
        singleEmission+=share*co2Density
    }
    co2Emissions+=plan.acceptedAmount*singleEmission*plan.out('SEGMENT_DISPATCHPLAN').collect{it.lengthInHours}[0]
}
return co2Emissions",

"Forc_CO2Emissions_inTonpA", "DecarbonizationModel", "ppdps=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.PowerPlantDispatchPlan']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick+3).filter{it.status>=1 && it.forecast==true}.collect();
co2Emissions = 0
for(plan in ppdps){
fuelMix=plan.out('POWERPLANT_DISPATCHPLAN').out('FUEL_MIX').collect()
singleEmission=0
    for(fuelMixElement in fuelMix){
        //fuelMixElement=fuelMix[1]
        share=fuelMixElement.share
        co2Density=fuelMixElement.out('SUBSTANCE').collect{it.co2Density}[0]*(1-plan.out('POWERPLANT_DISPATCHPLAN').out('TECHNOLOGY').collect{it.co2CaptureEffciency}[0])
        singleEmission+=share*co2Density
    }
    co2Emissions+=plan.acceptedAmount*singleEmission*plan.out('SEGMENT_DISPATCHPLAN').collect{it.lengthInHours}[0]
}
return co2Emissions",

"EUCO2PriceFloor", "Government", "try{price = v.out('MINCO2PRICE_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('MINCO2PRICE_TREND').timeSeries.next()[tick.toInteger()];};
return ['EU CO2 price floor', price];",

"CO2Tax", "Government", "try{price = v.out('CO2TAX_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
price = v.out('CO2TAX_TREND').timeSeries.next()[tick.toInteger()];}
return price",

"FuelPricesPerGJ", "DecarbonizationModel", "fuels = g.idx('__types__')[[className:'emlab.gen.domain.technology.Substance']].filter{it.name != 'Electricity' && it.name != 'CO2'}
result = []
for(v in fuels){
      price = v.in('SUBSTANCE_MARKET').in('MARKET_POINT').filter{it.time == tick}.collect{it.price};
      density = v.energyDensity;
      inGJ = price[0] / density;
      result.add([v.name,inGJ]);}
      return result",

"ProducerCash", "EnergyProducer", "[v.name, v.cash]",

"AggregateFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalLTCRevenue = 0;
totalCMRevenue = 0;
totalCO2HedgingRevenue=0;
for (key in groups.keySet()) {
    if (key<3 || key>9) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalRevenue += flow.money;
            }
        }
        
    } else {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCosts += flow.money;
            }
        }
    }
       
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalSpotRevenue += flow.money;
            }
        }
        
    }
    
     if (key==2) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalLTCRevenue += flow.money;
            }
        }
        
    }
    
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCMRevenue += flow.money;
            }
        }

if (key==12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCO2HedgingRevenue += flow.money;
            }
        }
        }
    }
}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue LTC', totalLTCRevenue]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['Revenue CM', totalCMRevenue]);
result.add(['Revenue CO2Hedge', totalCO2HedgingRevenue]);
result.add(['Profit', totalRevenue - totalCosts]);
return result;",

"CountryAProdFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalLTCRevenue = 0;
totalCMRevenue = 0;
totalRESRevenue=0;
totalCO2HedgingRevenue=0;
for (key in groups.keySet()) {
    if (key<3 || key>9) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalRevenue += flow.money;
            }
        }
        
    } else {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalCosts += flow.money;
            }
        }
    }
       
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalSpotRevenue += flow.money;
            }
        }
        
    }
    
     if (key==2) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalLTCRevenue += flow.money;
            }
        }
        
    }
    
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalCMRevenue += flow.money;
            }
        }
        
    }
    
        
             if (key==10) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
                totalRESRevenue += flow.money;
            }
        }
        
    }

if (key==12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCO2HedgingRevenue += flow.money;
            }
        }
        }

}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue LTC', totalLTCRevenue]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['Revenue CM', totalCMRevenue])
result.add(['Revenue RES',totalRESRevenue])
result.add(['Revenue CO2Hedge', totalCO2HedgingRevenue]);
result.add(['Profit', totalRevenue - totalCosts]);
return result;",

"CountryBProdFinances", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
totalCosts = 0;
totalRevenue = 0;
totalSpotRevenue = 0;
totalLTCRevenue = 0;
totalCMRevenue = 0;
totalRESRevenue=0;
totalCO2HedgingRevenue=0;
for (key in groups.keySet()) {
    if (key<3 || key>9) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalRevenue += flow.money;
            }
        }
        
    } else {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalCosts += flow.money;
            }
        }
    }
       
     if (key==1) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalSpotRevenue += flow.money;
            }
        }
        
    }
    
     if (key==2) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalLTCRevenue += flow.money;
            }
        }
        
    }
    
         if (key==11) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalCMRevenue += flow.money;
            }
        }
        
    }
    
        
             if (key==10) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('TO_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
                totalRESRevenue += flow.money;
            }
        }
        
    }

if (key==12) {
        for (flow in groups[key]) {
            if (flow.time != tick) continue;
            if (flow.out('TO_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
                totalCO2HedgingRevenue += flow.money;
            }
        }
        }

}
result.add(['Total Revenue', totalRevenue]);
result.add(['Revenue LTC', totalLTCRevenue]);
result.add(['Revenue Spot', totalSpotRevenue]);
result.add(['Revenue CM', totalCMRevenue])
result.add(['Revenue RES',totalRESRevenue])
result.add(['Revenue CO2Hedge', totalCO2HedgingRevenue]);
result.add(['Profit', totalRevenue - totalCosts]);
return result;",

"PriceInEURperMWh", "DecarbonizationModel", "results = []
points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
for(scp in points){
    results.add(['Segment ' + scp.out('MARKET_POINT').out('ZONE').name.next() + ' ' + scp.out('SEGMENT_POINT').segmentID.next(), scp.price])
}
return results",


"ShortagesInHoursUnserved", "DecarbonizationModel", "powerplants = g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']].filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}
production= powerplants.in('POWERPLANT_DISPATCHPLAN').sum{f.determineProductionOfDispatchPlanInMWh(it, tick)};
segmentloads = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentLoad']]
productionsum  = 0;
for(segmentload in segmentloads){
    try{growthfactor = segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
    growthfactor=segmentload.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}    
    productionsum += segmentload.out('SEGMENTLOAD_SEGMENT').lengthInHours.next() * segmentload.baseLoad * growthfactor;
}
return (production-productionsum)/productionsum*8760;",

"ProducerCosts", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
allKeys = []
for(i in 0..12)
    allKeys.add(i)
usedKeys=[]
for (key in allKeys) {
    usedKeys.add(key)
    sum = 0;
    if(key in groups.keySet()){
         for (flow in groups[key]) {
        if (flow.time != tick) continue;
        if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0]) {
            sum += flow.money;
            }
        }
    } 
    name='Unspecified';
    if(key==0){name='Unclassified';}
    if(key==1){name='Electricity spot';}
    if(key==2){name='Electricity ltc';}
    if(key==3){name='Fixed O&M';}
    if(key==4){name='Commodity';}
    if(key==5){name='CO2 tax';}
    if(key==6){name='CO2 auction';}
    if(key==7){name='Loan';}
    if(key==8){name='Downpayment';}
    if(key==9){name='National CO2 MinPrice';}
    if(key==10){name='Strategic Reserve';}
    if(key==11){name='Capacity Market';}
    if(key==12){name='CO2 Hedging';}
    result.add([name, sum]);
} 
return result;",

"CountryAProdCosts", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
allKeys = []
for(i in 0..12)
    allKeys.add(i)
usedKeys=[]
for (key in allKeys) {
    usedKeys.add(key)
    sum = 0;
    if(key in groups.keySet()){
         for (flow in groups[key]) {
        if (flow.time != tick) continue;
        if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country A')}[0]) {
            sum += flow.money;
            }
        }
    } 
    name='Unspecified';
    if(key==0){name='Unclassified';}
    if(key==1){name='Electricity spot';}
    if(key==2){name='Electricity ltc';}
    if(key==3){name='Fixed O&M';}
    if(key==4){name='Commodity';}
    if(key==5){name='CO2 tax';}
    if(key==6){name='CO2 auction';}
    if(key==7){name='Loan';}
    if(key==8){name='Downpayment';}
    if(key==9){name='National CO2 MinPrice';}
    if(key==10){name='Strategic Reserve';}
    if(key==11){name='Capacity Market';}
    if(key==12){name='CO2 Hedging';}
    result.add([name, sum]);
} 
return result;",

"CountryBProdCosts", "DecarbonizationModel", "flows = n.getNodes('CashFlow');
groups = flows.groupBy{it.type}
result = [];
allKeys = []
for(i in 0..12)
    allKeys.add(i)
usedKeys=[]
for (key in allKeys) {
    usedKeys.add(key)
    sum = 0;
    if(key in groups.keySet()){
         for (flow in groups[key]) {
        if (flow.time != tick) continue;
        if (flow.out('FROM_AGENT').collect{it.__type__.contains('EnergyProducer')}[0] && flow.out('FROM_AGENT').out('INVESTOR_MARKET').out('ZONE').collect{it.name.equals('Country B')}[0]) {
            sum += flow.money;
            }
        }
    } 
    name='Unspecified';
    if(key==0){name='Unclassified';}
    if(key==1){name='Electricity spot';}
    if(key==2){name='Electricity ltc';}
    if(key==3){name='Fixed O&M';}
    if(key==4){name='Commodity';}
    if(key==5){name='CO2 tax';}
    if(key==6){name='CO2 auction';}
    if(key==7){name='Loan';}
    if(key==8){name='Downpayment';}
    if(key==9){name='National CO2 MinPrice';}
    if(key==10){name='Strategic Reserve';}
    if(key==11){name='Capacity Market';}
    if(key==12){name='CO2 Hedging';}
    result.add([name, sum]);
} 
return result;",

"TABLE_SegmentClearingPoints", "DecarbonizationModel", "points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
finalResult = []
headers=['tick','volume','price','market','segmentID','segmentLength']
finalResult.add(headers)
for(v in points){
    finalResult.add([v.time, v.volume, v.price, v.out('MARKET_POINT').collect{it.name}[0], v.out('SEGMENT_POINT').collect{it.segmentID}[0], v.out('SEGMENT_POINT').collect{it.lengthInHours}[0]])
}
return finalResult;
",

"TABLE_DemandLevels", "DecarbonizationModel", "segmentLoads=ppdps=g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentLoad']];
finalResult = [];
columnNames=['tick', 'volume', 'market', 'segmentID', 'hours']
finalResult.add(columnNames)
for(s in segmentLoads){
market= s.in('SEGMENT_LOAD').collect{it.name}[0]
    try{growthfactor = s.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){  
    growthfactor=s.in('SEGMENT_LOAD').out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
segmentID=s.out('SEGMENTLOAD_SEGMENT').collect{it.segmentID}[0]
hours=s.out('SEGMENTLOAD_SEGMENT').collect{it.lengthInHours}[0]
finalResult.add([tick, s.baseLoad*growthfactor, market, segmentID, hours])
}
return finalResult",

"TABLE_ClearingPoints", "DecarbonizationModel", "points = g.idx('__types__')[[className:'emlab.gen.domain.market.ClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
finalResult = []
headers=['tick','volume','price',',market']
finalResult.add(headers)
for(v in points){
finalResult.add([v.time, v.volume, v.price, v.out('MARKET_POINT').collect{it.name}[0]])
}
return finalResult",

"TABLE_InitialPowerPlants", "DecarbonizationModel", "if(tick<1){
powerPlants=g.idx('__types__')[[className:'emlab.gen.domain.technology.PowerPlant']];
finalResult = [];
columnNames=['Name', 'Technology', 'Location', 'Age', 'Owner', 'Capacity', 'Efficiency']
finalResult.add(columnNames)
for(p in powerPlants){
name = p.name
technology = p.out('TECHNOLOGY').collect{it.name}[0]
location = p.out('LOCATION').collect{it.name}[0]
age = -p.constructionStartTime-p.actualLeadtime-p.actualPermittime
owner = p.out('POWERPLANT_OWNER').collect{it.name}[0]
capacity = p.actualNominalCapacity
efficiency = p.actualEfficiency
finalResult.add([name,technology,location,age,owner,capacity,efficiency])
}
return finalResult
}",

"SupplyRatioPerZone", "ElectricitySpotMarket", "topsegments = v.out('SEGMENT_LOAD').max{it.baseLoad}.baseLoad;
t = new Table();
ratio = 0;
try{growthfactors = v.out('DEMANDGROWTH_TREND').collect{f.getTrendValue(it, tick)}[0];} catch(Exception e){    
growthfactors=v.out('DEMANDGROWTH_TREND').timeSeries.next()[tick.toInteger()]}
adjustedTopSegments = topsegments*growthfactors;
pp = v.out('ZONE').in('REGION').in('LOCATION');
pp.filter{(it.dismantleTime > tick) && ((it.constructionStartTime + it.actualPermittime + it.actualLeadtime) <= tick)}.as('powerPlantCapacity').out('TECHNOLOGY').as('peakSegmentDependentAvailability').table(t){it.actualNominalCapacity}{it.peakSegmentDependentAvailability}.cap().next();
capacitySum = 0; for (row in t){capacitySum += row.getColumn('powerPlantCapacity') * row.getColumn('peakSegmentDependentAvailability')}
ratio = capacitySum / adjustedTopSegments;
return [v.outE('ZONE').inV.collect{it.name}[0], ratio]",


"MoneyModel", "DecarbonizationModel", "results = []
points = g.idx('__types__')[[className:'emlab.gen.domain.market.electricity.SegmentClearingPoint']].propertyFilter('time', FilterPipe.Filter.EQUAL, tick).propertyFilter('forecast', FilterPipe.Filter.EQUAL, false)
flowA1 = 0;
flowB1 = 0;
moneyA1 = 0;
moneyB1 = 0;
money1 = 0;
testA1 = 0;
testB1 = 0;
flowA2 = 0;
flowB2 = 0;
moneyA2 = 0;
moneyB2 = 0;
money2 = 0;
testA2 = 0;
testB2 = 0;
flowA3 = 0;
flowB3 = 0;
moneyA3 = 0;
moneyB3 = 0;
money3 = 0;
testA3 = 0;
testB3 = 0;
flowA4 = 0;
flowB4 = 0;
moneyA4 = 0;
moneyB4 = 0;
money4 = 0;
testA4 = 0;
testB4 = 0;
flowA5 = 0;
flowB5 = 0;
moneyA5 = 0;
moneyB5 = 0;
money5 = 0;
testA5 = 0;
testB5 = 0;
flowA6 = 0;
flowB6 = 0;
moneyA6 = 0;
moneyB6 = 0;
money6 = 0;
testA6 = 0;
testB6 = 0;
flowA7 = 0;
flowB7 = 0;
moneyA7 = 0;
moneyB7 = 0;
money7 = 0;
testA7 = 0;
testB7 = 0;
flowA8 = 0;
flowB8 = 0;
moneyA8 = 0;
moneyB8 = 0;
money8 = 0;
testA8 = 0;
testB8 = 0;
flowA9 = 0;
flowB9 = 0;
moneyA9 = 0;
moneyB9 = 0;
money9 = 0;
testA9 = 0;
testB9 = 0;
flowA10 = 0;
flowB10 = 0;
moneyA10 = 0;
moneyB10 = 0;
money10 = 0;
testA10 = 0;
testB10 = 0;
flowA11 = 0;
flowB11 = 0;
moneyA11 = 0;
moneyB11 = 0;
money11 = 0;
testA11 = 0;
testB11 = 0;
flowA12 = 0;
flowB12 = 0;
moneyA12 = 0;
moneyB12 = 0;
money12 = 0;
testA12 = 0;
testB12 = 0;
flowA13 = 0;
flowB13 = 0;
moneyA13 = 0;
moneyB13 = 0;
money13 = 0;
testA13 = 0;
testB13 = 0;
flowA14 = 0;
flowB14 = 0;
moneyA14 = 0;
moneyB14 = 0;
money14 = 0;
testA14 = 0;
testB14 = 0;
flowA15 = 0;
flowB15 = 0;
moneyA15 = 0;
moneyB15 = 0;
money15 = 0;
testA15 = 0;
testB15 = 0;
flowA16 = 0;
flowB16 = 0;
moneyA16 = 0;
moneyB16 = 0;
money16 = 0;
testA16 = 0;
testB16 = 0;
flowA17 = 0;
flowB17 = 0;
moneyA17 = 0;
moneyB17 = 0;
money17 = 0;
testA17 = 0;
testB17 = 0;
flowA18 = 0;
flowB18 = 0;
moneyA18 = 0;
moneyB18 = 0;
money18 = 0;
testA18 = 0;
testB18 = 0;
flowA19 = 0;
flowB19 = 0;
moneyA19 = 0;
moneyB19 = 0;
money19 = 0;
testA19 = 0;
testB19 = 0;
flowA20 = 0;
flowB20 = 0;
moneyA20 = 0;
moneyB20 = 0;
money20 = 0;
testA20 = 0;
testB20 = 0;
for(scp in points){

	market = scp.out('MARKET_POINT').out('ZONE').name.next();
	id = scp.out('SEGMENT_POINT').segmentID.next();
	
	if (id == 1) {
	if (market == 'Country A') { 
	flowA1 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA1 = scp.price;
	testA1 = 1;
	} else {
	flowB1 = scp.interconnectorFlow  * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB1 = scp.price;
	testB1 = 1;
	}
	}
	
    if (testA1 == 1 && testB1 == 1) {
	if (flowA1 > flowB1) {
	money1 = flowA1 * (moneyA1 - moneyB1);
	testA1 = 0;
	testB1 = 0;
	results.add([id, money1])
	} 
	else {
	money1 = flowB1 *(moneyB1 - moneyA1);
	testA1 = 0;
	testB1 = 0;
	results.add([id, money1])
	}
	}
	
	if (id == 2) {
	if (market == 'Country A') { 
	flowA2 = scp.interconnectorFlow  * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA2 = scp.price;
	testA2 = 1;
	} else {
	flowB2 = scp.interconnectorFlow  * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB2 = scp.price;
	testB2 = 1;
	}
	}
	
    if (testA2 == 1 && testB2 == 1) {
	if (flowA2 > flowB1) {
	money2 = flowA2 * (moneyA2 - moneyB2);
	testA2 = 0;
	testB2 = 0;
	results.add([id, money2])
	} 
	else {
	money2 = flowB2 * (moneyB2 - moneyA2);
	testA2 = 0;
	testB2 = 0;
	results.add([id, money2])
	}
	}
	
	
	if (id == 3) {
	if (market == 'Country A') { 
	flowA3 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA3 = scp.price;
	testA3 = 3;
	} else {
	flowB3 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB3 = scp.price;
	testB3 = 3;
	}
	}
	
    if (testA3 == 3 && testB3 == 3) {
	if (flowA3 > flowB3) {
	money3 = flowA3 * (moneyA3 - moneyB3);
	testA3 = 0;
	testB3 = 0;
	results.add([id, money3])
	} 
	else {
	money3 = flowB3 * (moneyB3 - moneyA3);
	testA3 = 0;
	testB3 = 0;
	results.add([id, money3])
	}
	}
	
	
	if (id == 4) {
	if (market == 'Country A') { 
	flowA4 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA4 = scp.price;
	testA4 = 4;
	} else {
	flowB4 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB4 = scp.price;
	testB4 = 4;
	}
	}
	
    if (testA4 == 4 && testB4 == 4) {
	if (flowA4 > flowB4) {
	money4 = flowA4 * (moneyA4 - moneyB4);
	testA4 = 0;
	testB4 = 0;
	results.add([id, money4])
	} 
	else {
	money4 = flowB4 * (moneyB4 - moneyA4);
	testA4 = 0;
	testB4 = 0;
	results.add([id, money4])
	}
	}
	
	if (id == 5) {
	if (market == 'Country A') { 
	flowA5 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA5 = scp.price;
	testA5 = 5;
	} else {
	flowB5 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB5 = scp.price;
	testB5 = 5;
	}
	}
	
    if (testA5 == 5 && testB5 == 5) {
	if (flowA5 > flowB5) {
	money5 = flowA5 * (moneyA5 - moneyB5);
	testA5 = 0;
	testB5 = 0;
	results.add([id, money5])
	} 
	else {
	money5 = flowB5 * (moneyB5 - moneyA5);
	testA5 = 0;
	testB5 = 0;
	results.add([id, money5])
	}
	}
	
	if (id == 6) {
	if (market == 'Country A') { 
	flowA6 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA6 = scp.price;
	testA6 = 6;
	} else {
	flowB6 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB6 = scp.price;
	testB6 = 6;
	}
	}
	
    if (testA6 == 6 && testB6 == 6) {
	if (flowA6 > flowB6) {
	money6 = flowA6 * (moneyA6 - moneyB6);
	testA6 = 0;
	testB6 = 0;
	results.add([id, money6])
	} 
	else {
	money6 = flowB6 * (moneyB6 - moneyA6);
	testA6 = 0;
	testB6 = 0;
	results.add([id, money6])
	}
	}
	
	if (id == 7) {
	if (market == 'Country A') { 
	flowA7 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA7 = scp.price;
	testA7 = 7;
	} else {
	flowB7 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB7 = scp.price;
	testB7 = 7;
	}
	}
	
    if (testA7 == 7 && testB7 == 7) {
	if (flowA7 > flowB7) {
	money7 = flowA7 * (moneyA7 - moneyB7);
	testA7 = 0;
	testB7 = 0;
	results.add([id, money7])
	} 
	else {
	money7 = flowB7 * (moneyB7 - moneyA7);
	testA7 = 0;
	testB7 = 0;
	results.add([id, money7])
	}
	}
	
	if (id == 8) {
	if (market == 'Country A') { 
	flowA8 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA8 = scp.price;
	testA8 = 8;
	} else {
	flowB8 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB8 = scp.price;
	testB8 = 8;
	}
	}
	
    if (testA8 == 8 && testB8 == 8) {
	if (flowA8 > flowB8) {
	money8 = flowA8 * (moneyA8 - moneyB8);
	testA8 = 0;
	testB8 = 0;
	results.add([id, money8])
	} 
	else {
	money8 = flowB8 * (moneyB8 - moneyA8);
	testA8 = 0;
	testB8 = 0;
	results.add([id, money8])
	}
	}
	
	if (id == 9) {
	if (market == 'Country A') { 
	flowA9 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA9 = scp.price;
	testA9 = 9;
	} else {
	flowB9 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB9 = scp.price;
	testB9 = 9;
	}
	}
	
    if (testA9 == 9 && testB9 == 9) {
	if (flowA9 > flowB9) {
	money9 = flowA9 * (moneyA9 - moneyB9);
	testA9 = 0;
	testB9 = 0;
	results.add([id, money9])
	} 
	else {
	money9 = flowB9 * (moneyB9 - moneyA9);
	testA9 = 0;
	testB9 = 0;
	results.add([id, money9])
	}
	}
	
	if (id == 10) {
	if (market == 'Country A') { 
	flowA10 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA10 = scp.price;
	testA10 = 10;
	} else {
	flowB10 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB10 = scp.price;
	testB10 = 10;
	}
	}
	
    if (testA10 == 10 && testB10 == 10) {
	if (flowA10 > flowB10) {
	money10 = flowA10 * (moneyA10 - moneyB10);
	testA10 = 0;
	testB10 = 0;
	results.add([id, money10])
	} 
	else {
	money10 = flowB10 * (moneyB10 - moneyA10);
	testA10 = 0;
	testB10 = 0;
	results.add([id, money10])
	}
	}
	
	if (id == 11) {
	if (market == 'Country A') { 
	flowA11 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA11 = scp.price;
	testA11 = 11;
	} else {
	flowB11 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB11 = scp.price;
	testB11 = 11;
	}
	}
	
    if (testA11 == 11 && testB11 == 11) {
	if (flowA11 > flowB11) {
	money11 = flowA11 * (moneyA11 - moneyB11);
	testA11 = 0;
	testB11 = 0;
	results.add([id, money11])
	} 
	else {
	money11 = flowB11 * (moneyB11 - moneyA11);
	testA11 = 0;
	testB11 = 0;
	results.add([id, money11])
	}
	}
	
	if (id == 12) {
	if (market == 'Country A') { 
	flowA12 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA12 = scp.price;
	testA12 = 12;
	} else {
	flowB12 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB12 = scp.price;
	testB12 = 12;
	}
	}
	
    if (testA12 == 12 && testB12 == 12) {
	if (flowA12 > flowB12) {
	money12 = flowA12 * (moneyA12 - moneyB12);
	testA12 = 0;
	testB12 = 0;
	results.add([id, money12])
	} 
	else {
	money12 = flowB12 * (moneyB12 - moneyA12);
	testA12 = 0;
	testB12 = 0;
	results.add([id, money12])
	}
	}
	
	
	if (id == 13) {
	if (market == 'Country A') { 
	flowA13 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA13 = scp.price;
	testA13 = 13;
	} else {
	flowB13 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB13 = scp.price;
	testB13 = 13;
	}
	}
	
    if (testA13 == 13 && testB13 == 13) {
	if (flowA13 > flowB13) {
	money13 = flowA13 * (moneyA13 - moneyB13);
	testA13 = 0;
	testB13 = 0;
	results.add([id, money13])
	} 
	else {
	money13 = flowB13 * (moneyB13 - moneyA13);
	testA13 = 0;
	testB13 = 0;
	results.add([id, money13])
	}
	}
	
	if (id == 14) {
	if (market == 'Country A') { 
	flowA14 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA14 = scp.price;
	testA14 = 14;
	} else {
	flowB14 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB14 = scp.price;
	testB14 = 14;
	}
	}
	
    if (testA14 == 14 && testB14 == 14) {
	if (flowA14 > flowB14) {
	money14 = flowA14 * (moneyA14 - moneyB14);
	testA14 = 0;
	testB14 = 0;
	results.add([id, money14])
	} 
	else {
	money14 = flowB14 * (moneyB14 - moneyA14);
	testA14 = 0;
	testB14 = 0;
	results.add([id, money14])
	}
	}
	
	if (id == 15) {
	if (market == 'Country A') { 
	flowA15 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA15 = scp.price;
	testA15 = 15;
	} else {
	flowB15 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB15 = scp.price;
	testB15 = 15;
	}
	}
	
    if (testA15 == 15 && testB15 == 15) {
	if (flowA15 > flowB15) {
	money15 = flowA15 * (moneyA15 - moneyB15);
	testA15 = 0;
	testB15 = 0;
	results.add([id, money15])
	} 
	else {
	money15 = flowB15 * (moneyB15 - moneyA15);
	testA15 = 0;
	testB15 = 0;
	results.add([id, money15])
	}
	}
	
	if (id == 16) {
	if (market == 'Country A') { 
	flowA16 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA16 = scp.price;
	testA16 = 16;
	} else {
	flowB16 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB16 = scp.price;
	testB16 = 16;
	}
	}
	
    if (testA16 == 16 && testB16 == 16) {
	if (flowA16 > flowB16) {
	money16 = flowA16 * (moneyA16 - moneyB16);
	testA16 = 0;
	testB16 = 0;
	results.add([id, money16])
	} 
	else {
	money16 = flowB16 * (moneyB16 - moneyA16);
	testA16 = 0;
	testB16 = 0;
	results.add([id, money16])
	}
	}
	
	if (id == 17) {
	if (market == 'Country A') { 
	flowA17 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA17 = scp.price;
	testA17 = 17;
	} else {
	flowB17 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB17 = scp.price;
	testB17 = 17;
	}
	}
	
    if (testA17 == 17 && testB17 == 17) {
	if (flowA17 > flowB17) {
	money17 = flowA17 * (moneyA17 - moneyB17);
	testA17 = 0;
	testB17 = 0;
	results.add([id, money17])
	} 
	else {
	money17 = flowB17 * (moneyB17 - moneyA17);
	testA17 = 0;
	testB17 = 0;
	results.add([id, money17])
	}
	}
	
	if (id == 18) {
	if (market == 'Country A') { 
	flowA18 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA18 = scp.price;
	testA18 = 18;
	} else {
	flowB18 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB18 = scp.price;
	testB18 = 18;
	}
	}
	
    if (testA18 == 18 && testB18 == 18) {
	if (flowA18 > flowB18) {
	money18 = flowA18 * (moneyA18 - moneyB18);
	testA18 = 0;
	testB18 = 0;
	results.add([id, money18])
	} 
	else {
	money18 = flowB18 * (moneyB18 - moneyA18);
	testA18 = 0;
	testB18 = 0;
	results.add([id, money18])
	}
	}
	
	if (id == 19) {
	if (market == 'Country A') { 
	flowA19 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA19 = scp.price;
	testA19 = 19;
	} else {
	flowB19 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB19 = scp.price;
	testB19 = 19;
	}
	}
	
    if (testA19 == 19 && testB19 == 19) {
	if (flowA19 > flowB19) {
	money19 = flowA19 * (moneyA19 - moneyB19);
	testA19 = 0;
	testB19 = 0;
	results.add([id, money19])
	} 
	else {
	money19 = flowB19 * (moneyB19 - moneyA19);
	testA19 = 0;
	testB19 = 0;
	results.add([id, money19])
	}
	}
	
	if (id == 20) {
	if (market == 'Country A') { 
	flowA20 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyA20 = scp.price;
	testA20 = 20;
	} else {
	flowB20 = scp.interconnectorFlow * scp.out('SEGMENT_POINT').lengthInHours.next();
	moneyB20 = scp.price;
	testB20 = 20;
	}
	}
	
    if (testA20 == 20 && testB20 == 20) {
	if (flowA20 > flowB20) {
	money20 = flowA20 * (moneyA20 - moneyB20);
	testA20 = 0;
	testB20 = 0;
	results.add([id, money20])
	} 
	else {
	money20 = flowB20 * (moneyB20 - moneyA20);
	testA20 = 0;
	testB20 = 0;
	results.add([id, money20])
	}
	}
	
	
	money = money1 + money2 + money3 + money4 + money5 + money6 + money7 + money8 + money9 + money10 + money11 + money12 + money13 + money14 + money15 + money16 + money17 + money18 + money19 + money20;
	
}
return ['Profit', money]",

